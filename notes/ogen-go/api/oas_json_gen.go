// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Address) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Address) encodeFields(e *jx.Encoder) {
	{
		if s.FirstName.Set {
			e.FieldStart("First_name")
			s.FirstName.Encode(e)
		}
	}
	{
		if s.LastName.Set {
			e.FieldStart("Last_name")
			s.LastName.Encode(e)
		}
	}
	{
		e.FieldStart("Street_addr")
		e.Str(s.StreetAddr)
	}
	{
		if s.StreetAddr2.Set {
			e.FieldStart("Street_addr_2")
			s.StreetAddr2.Encode(e)
		}
	}
	{
		if s.City.Set {
			e.FieldStart("City")
			s.City.Encode(e)
		}
	}
	{
		e.FieldStart("State")
		e.Str(s.State)
	}
	{
		e.FieldStart("Postcode")
		e.Str(s.Postcode)
	}
	{
		e.FieldStart("Country")
		e.Str(s.Country)
	}
	{
		if s.AddressCreated.Set {
			e.FieldStart("Address_created")
			s.AddressCreated.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfAddress = [9]string{
	0: "First_name",
	1: "Last_name",
	2: "Street_addr",
	3: "Street_addr_2",
	4: "City",
	5: "State",
	6: "Postcode",
	7: "Country",
	8: "Address_created",
}

// Decode decodes Address from json.
func (s *Address) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Address to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "First_name":
			if err := func() error {
				s.FirstName.Reset()
				if err := s.FirstName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"First_name\"")
			}
		case "Last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Last_name\"")
			}
		case "Street_addr":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StreetAddr = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Street_addr\"")
			}
		case "Street_addr_2":
			if err := func() error {
				s.StreetAddr2.Reset()
				if err := s.StreetAddr2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Street_addr_2\"")
			}
		case "City":
			if err := func() error {
				s.City.Reset()
				if err := s.City.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"City\"")
			}
		case "State":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"State\"")
			}
		case "Postcode":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Postcode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Postcode\"")
			}
		case "Country":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Country = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Country\"")
			}
		case "Address_created":
			if err := func() error {
				s.AddressCreated.Reset()
				if err := s.AddressCreated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Address_created\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Address")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11100100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddress) {
					name = jsonFieldsNameOfAddress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Address) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Address) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Contact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Contact) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Contact_phone")
		e.Str(s.ContactPhone)
	}
	{
		e.FieldStart("Contact_email")
		e.Str(s.ContactEmail)
	}
	{
		if s.ContactAddressID.Set {
			e.FieldStart("Contact_address_id")
			s.ContactAddressID.Encode(e)
		}
	}
}

var jsonFieldsNameOfContact = [3]string{
	0: "Contact_phone",
	1: "Contact_email",
	2: "Contact_address_id",
}

// Decode decodes Contact from json.
func (s *Contact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Contact to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Contact_phone":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ContactPhone = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Contact_phone\"")
			}
		case "Contact_email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ContactEmail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Contact_email\"")
			}
		case "Contact_address_id":
			if err := func() error {
				s.ContactAddressID.Reset()
				if err := s.ContactAddressID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Contact_address_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Contact")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContact) {
					name = jsonFieldsNameOfContact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Contact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Contact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Outcome.Set {
			e.FieldStart("outcome")
			s.Outcome.Encode(e)
		}
	}
	{
		if s.NonMinusFatal != nil {
			e.FieldStart("non-fatal")
			e.ArrStart()
			for _, elem := range s.NonMinusFatal {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGoResponse = [3]string{
	0: "message",
	1: "outcome",
	2: "non-fatal",
}

// Decode decodes GoResponse from json.
func (s *GoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "outcome":
			if err := func() error {
				s.Outcome.Reset()
				if err := s.Outcome.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outcome\"")
			}
		case "non-fatal":
			if err := func() error {
				s.NonMinusFatal = make([]GoResponseNonMinusFatalItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GoResponseNonMinusFatalItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NonMinusFatal = append(s.NonMinusFatal, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"non-fatal\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoResponseNonMinusFatalItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoResponseNonMinusFatalItem) encodeFields(e *jx.Encoder) {
	{
		if s.DbTablePath.Set {
			e.FieldStart("db_table_path")
			s.DbTablePath.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfGoResponseNonMinusFatalItem = [2]string{
	0: "db_table_path",
	1: "error",
}

// Decode decodes GoResponseNonMinusFatalItem from json.
func (s *GoResponseNonMinusFatalItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoResponseNonMinusFatalItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "db_table_path":
			if err := func() error {
				s.DbTablePath.Reset()
				if err := s.DbTablePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_table_path\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoResponseNonMinusFatalItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoResponseNonMinusFatalItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoResponseNonMinusFatalItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GoResponseOutcome as json.
func (s GoResponseOutcome) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GoResponseOutcome from json.
func (s *GoResponseOutcome) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoResponseOutcome to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GoResponseOutcome(v) {
	case GoResponseOutcomeSuccess:
		*s = GoResponseOutcomeSuccess
	case GoResponseOutcomeFailed:
		*s = GoResponseOutcomeFailed
	default:
		*s = GoResponseOutcome(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GoResponseOutcome) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoResponseOutcome) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Address as json.
func (o OptAddress) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Address from json.
func (o *OptAddress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAddress to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAddress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAddress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Contact as json.
func (o OptContact) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Contact from json.
func (o *OptContact) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContact to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDate to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GoResponseOutcome as json.
func (o OptGoResponseOutcome) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GoResponseOutcome from json.
func (o *OptGoResponseOutcome) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGoResponseOutcome to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGoResponseOutcome) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGoResponseOutcome) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes netip.Addr as json.
func (o OptIPv4) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeIPv4(e, o.Value)
}

// Decode decodes netip.Addr from json.
func (o *OptIPv4) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIPv4 to nil")
	}
	o.Set = true
	v, err := json.DecodeIPv4(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIPv4) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIPv4) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderBilling as json.
func (o OptOrderBilling) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrderBilling from json.
func (o *OptOrderBilling) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrderBilling to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrderBilling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrderBilling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderDetail as json.
func (o OptOrderDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrderDetail from json.
func (o *OptOrderDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrderDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrderDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrderDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderShipping as json.
func (o OptOrderShipping) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrderShipping from json.
func (o *OptOrderShipping) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrderShipping to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrderShipping) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrderShipping) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderTransaction as json.
func (o OptOrderTransaction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrderTransaction from json.
func (o *OptOrderTransaction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrderTransaction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrderTransaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrderTransaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Payment as json.
func (o OptPayment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Payment from json.
func (o *OptPayment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPayment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPayment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPayment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PaymentCCType as json.
func (o OptPaymentCCType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PaymentCCType from json.
func (o *OptPaymentCCType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPaymentCCType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPaymentCCType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPaymentCCType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Order) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Order) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Ingestion_provider_id")
		e.Int(s.IngestionProviderID)
	}
	{
		e.FieldStart("Company_id")
		e.Int(s.CompanyID)
	}
	{
		if s.OrderUUID.Set {
			e.FieldStart("Order_uuid")
			s.OrderUUID.Encode(e)
		}
	}
	{
		if s.ClientOrderID.Set {
			e.FieldStart("Client_order_id")
			s.ClientOrderID.Encode(e)
		}
	}
	{
		if s.CrmAccountID.Set {
			e.FieldStart("Crm_account_id")
			s.CrmAccountID.Encode(e)
		}
	}
	{
		if s.OrderStatus.Set {
			e.FieldStart("Order_status")
			s.OrderStatus.Encode(e)
		}
	}
	{
		if s.OrderCreated.Set {
			e.FieldStart("Order_created")
			s.OrderCreated.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.OrderDetail.Set {
			e.FieldStart("Order_detail")
			s.OrderDetail.Encode(e)
		}
	}
	{
		if s.OrderBilling.Set {
			e.FieldStart("Order_billing")
			s.OrderBilling.Encode(e)
		}
	}
	{
		if s.OrderTransaction.Set {
			e.FieldStart("Order_transaction")
			s.OrderTransaction.Encode(e)
		}
	}
	{
		if s.OrderProduct != nil {
			e.FieldStart("Order_product")
			s.OrderProduct.Encode(e)
		}
	}
	{
		if s.OrderShipping.Set {
			e.FieldStart("Order_shipping")
			s.OrderShipping.Encode(e)
		}
	}
	{
		if s.OrderNote != nil {
			e.FieldStart("Order_note")
			s.OrderNote.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrder = [13]string{
	0:  "Ingestion_provider_id",
	1:  "Company_id",
	2:  "Order_uuid",
	3:  "Client_order_id",
	4:  "Crm_account_id",
	5:  "Order_status",
	6:  "Order_created",
	7:  "Order_detail",
	8:  "Order_billing",
	9:  "Order_transaction",
	10: "Order_product",
	11: "Order_shipping",
	12: "Order_note",
}

// Decode decodes Order from json.
func (s *Order) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Order to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Ingestion_provider_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.IngestionProviderID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Ingestion_provider_id\"")
			}
		case "Company_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CompanyID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Company_id\"")
			}
		case "Order_uuid":
			if err := func() error {
				s.OrderUUID.Reset()
				if err := s.OrderUUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_uuid\"")
			}
		case "Client_order_id":
			if err := func() error {
				s.ClientOrderID.Reset()
				if err := s.ClientOrderID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Client_order_id\"")
			}
		case "Crm_account_id":
			if err := func() error {
				s.CrmAccountID.Reset()
				if err := s.CrmAccountID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Crm_account_id\"")
			}
		case "Order_status":
			if err := func() error {
				s.OrderStatus.Reset()
				if err := s.OrderStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_status\"")
			}
		case "Order_created":
			if err := func() error {
				s.OrderCreated.Reset()
				if err := s.OrderCreated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_created\"")
			}
		case "Order_detail":
			if err := func() error {
				s.OrderDetail.Reset()
				if err := s.OrderDetail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_detail\"")
			}
		case "Order_billing":
			if err := func() error {
				s.OrderBilling.Reset()
				if err := s.OrderBilling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_billing\"")
			}
		case "Order_transaction":
			if err := func() error {
				s.OrderTransaction.Reset()
				if err := s.OrderTransaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_transaction\"")
			}
		case "Order_product":
			if err := func() error {
				if err := s.OrderProduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_product\"")
			}
		case "Order_shipping":
			if err := func() error {
				s.OrderShipping.Reset()
				if err := s.OrderShipping.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_shipping\"")
			}
		case "Order_note":
			if err := func() error {
				if err := s.OrderNote.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_note\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Order")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrder) {
					name = jsonFieldsNameOfOrder[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Order) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Order) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderBilling) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderBilling) encodeFields(e *jx.Encoder) {
	{
		if s.Mid.Set {
			e.FieldStart("Mid")
			s.Mid.Encode(e)
		}
	}
	{
		if s.OrderTotal.Set {
			e.FieldStart("Order_total")
			s.OrderTotal.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("Currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.UsdAmount.Set {
			e.FieldStart("Usd_amount")
			s.UsdAmount.Encode(e)
		}
	}
	{
		if s.SalesTax.Set {
			e.FieldStart("Sales_tax")
			s.SalesTax.Encode(e)
		}
	}
	{
		if s.SalesTaxAmount.Set {
			e.FieldStart("Sales_tax_amount")
			s.SalesTaxAmount.Encode(e)
		}
	}
	{
		if s.TotalAmountRefunded.Set {
			e.FieldStart("Total_amount_refunded")
			s.TotalAmountRefunded.Encode(e)
		}
	}
	{
		if s.BillingCycle.Set {
			e.FieldStart("Billing_cycle")
			s.BillingCycle.Encode(e)
		}
	}
	{
		if s.RecurringDate.Set {
			e.FieldStart("Recurring_date")
			s.RecurringDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.RetryDate.Set {
			e.FieldStart("Retry_date")
			s.RetryDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.BillingAddressID.Set {
			e.FieldStart("Billing_address_id")
			s.BillingAddressID.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrderBilling = [11]string{
	0:  "Mid",
	1:  "Order_total",
	2:  "Currency",
	3:  "Usd_amount",
	4:  "Sales_tax",
	5:  "Sales_tax_amount",
	6:  "Total_amount_refunded",
	7:  "Billing_cycle",
	8:  "Recurring_date",
	9:  "Retry_date",
	10: "Billing_address_id",
}

// Decode decodes OrderBilling from json.
func (s *OrderBilling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderBilling to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Mid":
			if err := func() error {
				s.Mid.Reset()
				if err := s.Mid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Mid\"")
			}
		case "Order_total":
			if err := func() error {
				s.OrderTotal.Reset()
				if err := s.OrderTotal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_total\"")
			}
		case "Currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Currency\"")
			}
		case "Usd_amount":
			if err := func() error {
				s.UsdAmount.Reset()
				if err := s.UsdAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Usd_amount\"")
			}
		case "Sales_tax":
			if err := func() error {
				s.SalesTax.Reset()
				if err := s.SalesTax.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Sales_tax\"")
			}
		case "Sales_tax_amount":
			if err := func() error {
				s.SalesTaxAmount.Reset()
				if err := s.SalesTaxAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Sales_tax_amount\"")
			}
		case "Total_amount_refunded":
			if err := func() error {
				s.TotalAmountRefunded.Reset()
				if err := s.TotalAmountRefunded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Total_amount_refunded\"")
			}
		case "Billing_cycle":
			if err := func() error {
				s.BillingCycle.Reset()
				if err := s.BillingCycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Billing_cycle\"")
			}
		case "Recurring_date":
			if err := func() error {
				s.RecurringDate.Reset()
				if err := s.RecurringDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Recurring_date\"")
			}
		case "Retry_date":
			if err := func() error {
				s.RetryDate.Reset()
				if err := s.RetryDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Retry_date\"")
			}
		case "Billing_address_id":
			if err := func() error {
				s.BillingAddressID.Reset()
				if err := s.BillingAddressID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Billing_address_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderBilling")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderBilling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderBilling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderDetail) encodeFields(e *jx.Encoder) {
	{
		if s.CustomerID.Set {
			e.FieldStart("Customer_id")
			s.CustomerID.Encode(e)
		}
	}
	{
		if s.AncestorID.Set {
			e.FieldStart("Ancestor_id")
			s.AncestorID.Encode(e)
		}
	}
	{
		if s.ParentID.Set {
			e.FieldStart("Parent_id")
			s.ParentID.Encode(e)
		}
	}
	{
		if s.ChildID.Set {
			e.FieldStart("Child_id")
			s.ChildID.Encode(e)
		}
	}
	{
		if s.CrmRefunded.Set {
			e.FieldStart("Crm_refunded")
			s.CrmRefunded.Encode(e)
		}
	}
	{
		if s.CrmBlacklisted.Set {
			e.FieldStart("Crm_blacklisted")
			s.CrmBlacklisted.Encode(e)
		}
	}
	{
		if s.CrmStoppedRecurring.Set {
			e.FieldStart("Crm_stopped_recurring")
			s.CrmStoppedRecurring.Encode(e)
		}
	}
	{
		if s.IPAddress.Set {
			e.FieldStart("Ip_address")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.Affiliate.Set {
			e.FieldStart("Affiliate")
			s.Affiliate.Encode(e)
		}
	}
	{
		if s.SubAffiliate.Set {
			e.FieldStart("Sub_affiliate")
			s.SubAffiliate.Encode(e)
		}
	}
	{
		if s.CampaignID.Set {
			e.FieldStart("Campaign_id")
			s.CampaignID.Encode(e)
		}
	}
	{
		if s.ClickID.Set {
			e.FieldStart("Click_id")
			s.ClickID.Encode(e)
		}
	}
	{
		if s.Resolved.Set {
			e.FieldStart("Resolved")
			s.Resolved.Encode(e)
		}
	}
	{
		if s.OnHoldBy.Set {
			e.FieldStart("On_hold_by")
			s.OnHoldBy.Encode(e)
		}
	}
	{
		if s.OnHoldDate.Set {
			e.FieldStart("On_hold_date")
			s.OnHoldDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.OrderConfirmed.Set {
			e.FieldStart("Order_confirmed")
			s.OrderConfirmed.Encode(e)
		}
	}
	{
		if s.OrderConfirmedDate.Set {
			e.FieldStart("Order_confirmed_date")
			s.OrderConfirmedDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.OrderDate.Set {
			e.FieldStart("Order_date")
			s.OrderDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.DetailCreated.Set {
			e.FieldStart("Detail_created")
			s.DetailCreated.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DetailUpdated.Set {
			e.FieldStart("Detail_updated")
			s.DetailUpdated.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.OrderContactID.Set {
			e.FieldStart("Order_contact_id")
			s.OrderContactID.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrderDetail = [21]string{
	0:  "Customer_id",
	1:  "Ancestor_id",
	2:  "Parent_id",
	3:  "Child_id",
	4:  "Crm_refunded",
	5:  "Crm_blacklisted",
	6:  "Crm_stopped_recurring",
	7:  "Ip_address",
	8:  "Affiliate",
	9:  "Sub_affiliate",
	10: "Campaign_id",
	11: "Click_id",
	12: "Resolved",
	13: "On_hold_by",
	14: "On_hold_date",
	15: "Order_confirmed",
	16: "Order_confirmed_date",
	17: "Order_date",
	18: "Detail_created",
	19: "Detail_updated",
	20: "Order_contact_id",
}

// Decode decodes OrderDetail from json.
func (s *OrderDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderDetail to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Customer_id":
			if err := func() error {
				s.CustomerID.Reset()
				if err := s.CustomerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Customer_id\"")
			}
		case "Ancestor_id":
			if err := func() error {
				s.AncestorID.Reset()
				if err := s.AncestorID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Ancestor_id\"")
			}
		case "Parent_id":
			if err := func() error {
				s.ParentID.Reset()
				if err := s.ParentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Parent_id\"")
			}
		case "Child_id":
			if err := func() error {
				s.ChildID.Reset()
				if err := s.ChildID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Child_id\"")
			}
		case "Crm_refunded":
			if err := func() error {
				s.CrmRefunded.Reset()
				if err := s.CrmRefunded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Crm_refunded\"")
			}
		case "Crm_blacklisted":
			if err := func() error {
				s.CrmBlacklisted.Reset()
				if err := s.CrmBlacklisted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Crm_blacklisted\"")
			}
		case "Crm_stopped_recurring":
			if err := func() error {
				s.CrmStoppedRecurring.Reset()
				if err := s.CrmStoppedRecurring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Crm_stopped_recurring\"")
			}
		case "Ip_address":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Ip_address\"")
			}
		case "Affiliate":
			if err := func() error {
				s.Affiliate.Reset()
				if err := s.Affiliate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Affiliate\"")
			}
		case "Sub_affiliate":
			if err := func() error {
				s.SubAffiliate.Reset()
				if err := s.SubAffiliate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Sub_affiliate\"")
			}
		case "Campaign_id":
			if err := func() error {
				s.CampaignID.Reset()
				if err := s.CampaignID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Campaign_id\"")
			}
		case "Click_id":
			if err := func() error {
				s.ClickID.Reset()
				if err := s.ClickID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Click_id\"")
			}
		case "Resolved":
			if err := func() error {
				s.Resolved.Reset()
				if err := s.Resolved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Resolved\"")
			}
		case "On_hold_by":
			if err := func() error {
				s.OnHoldBy.Reset()
				if err := s.OnHoldBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"On_hold_by\"")
			}
		case "On_hold_date":
			if err := func() error {
				s.OnHoldDate.Reset()
				if err := s.OnHoldDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"On_hold_date\"")
			}
		case "Order_confirmed":
			if err := func() error {
				s.OrderConfirmed.Reset()
				if err := s.OrderConfirmed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_confirmed\"")
			}
		case "Order_confirmed_date":
			if err := func() error {
				s.OrderConfirmedDate.Reset()
				if err := s.OrderConfirmedDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_confirmed_date\"")
			}
		case "Order_date":
			if err := func() error {
				s.OrderDate.Reset()
				if err := s.OrderDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_date\"")
			}
		case "Detail_created":
			if err := func() error {
				s.DetailCreated.Reset()
				if err := s.DetailCreated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Detail_created\"")
			}
		case "Detail_updated":
			if err := func() error {
				s.DetailUpdated.Reset()
				if err := s.DetailUpdated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Detail_updated\"")
			}
		case "Order_contact_id":
			if err := func() error {
				s.OrderContactID.Reset()
				if err := s.OrderContactID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_contact_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderNote as json.
func (s OrderNote) Encode(e *jx.Encoder) {
	unwrapped := []OrderNoteItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OrderNote from json.
func (s *OrderNote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderNote to nil")
	}
	var unwrapped []OrderNoteItem
	if err := func() error {
		unwrapped = make([]OrderNoteItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrderNoteItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrderNote(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrderNote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderNote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderNoteItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderNoteItem) encodeFields(e *jx.Encoder) {
	{
		if s.NoteMessage.Set {
			e.FieldStart("Note_message")
			s.NoteMessage.Encode(e)
		}
	}
	{
		if s.NoteCreated.Set {
			e.FieldStart("Note_created")
			s.NoteCreated.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfOrderNoteItem = [2]string{
	0: "Note_message",
	1: "Note_created",
}

// Decode decodes OrderNoteItem from json.
func (s *OrderNoteItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderNoteItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Note_message":
			if err := func() error {
				s.NoteMessage.Reset()
				if err := s.NoteMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Note_message\"")
			}
		case "Note_created":
			if err := func() error {
				s.NoteCreated.Reset()
				if err := s.NoteCreated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Note_created\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderNoteItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderNoteItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderNoteItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderProduct as json.
func (s OrderProduct) Encode(e *jx.Encoder) {
	unwrapped := []OrderProductItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OrderProduct from json.
func (s *OrderProduct) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderProduct to nil")
	}
	var unwrapped []OrderProductItem
	if err := func() error {
		unwrapped = make([]OrderProductItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrderProductItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrderProduct(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrderProduct) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderProduct) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderProductItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderProductItem) encodeFields(e *jx.Encoder) {
	{
		if s.ProductID.Set {
			e.FieldStart("Product_id")
			s.ProductID.Encode(e)
		}
	}
	{
		if s.ProductQuantity.Set {
			e.FieldStart("Product_quantity")
			s.ProductQuantity.Encode(e)
		}
	}
	{
		if s.UpsellProductID.Set {
			e.FieldStart("Upsell_product_id")
			s.UpsellProductID.Encode(e)
		}
	}
	{
		if s.UpsellProductQuantity.Set {
			e.FieldStart("Upsell_product_quantity")
			s.UpsellProductQuantity.Encode(e)
		}
	}
	{
		if s.OrderProductCreated.Set {
			e.FieldStart("Order_product_created")
			s.OrderProductCreated.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfOrderProductItem = [5]string{
	0: "Product_id",
	1: "Product_quantity",
	2: "Upsell_product_id",
	3: "Upsell_product_quantity",
	4: "Order_product_created",
}

// Decode decodes OrderProductItem from json.
func (s *OrderProductItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderProductItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Product_id":
			if err := func() error {
				s.ProductID.Reset()
				if err := s.ProductID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Product_id\"")
			}
		case "Product_quantity":
			if err := func() error {
				s.ProductQuantity.Reset()
				if err := s.ProductQuantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Product_quantity\"")
			}
		case "Upsell_product_id":
			if err := func() error {
				s.UpsellProductID.Reset()
				if err := s.UpsellProductID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Upsell_product_id\"")
			}
		case "Upsell_product_quantity":
			if err := func() error {
				s.UpsellProductQuantity.Reset()
				if err := s.UpsellProductQuantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Upsell_product_quantity\"")
			}
		case "Order_product_created":
			if err := func() error {
				s.OrderProductCreated.Reset()
				if err := s.OrderProductCreated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Order_product_created\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderProductItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderProductItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderProductItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderShipping) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderShipping) encodeFields(e *jx.Encoder) {
	{
		if s.ShippingMethodName.Set {
			e.FieldStart("Shipping_method_name")
			s.ShippingMethodName.Encode(e)
		}
	}
	{
		if s.ShippingDate.Set {
			e.FieldStart("Shipping_date")
			s.ShippingDate.Encode(e)
		}
	}
	{
		if s.TrackingNumber.Set {
			e.FieldStart("Tracking_number")
			s.TrackingNumber.Encode(e)
		}
	}
	{
		if s.ShippingAddressID.Set {
			e.FieldStart("Shipping_address_id")
			s.ShippingAddressID.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrderShipping = [4]string{
	0: "Shipping_method_name",
	1: "Shipping_date",
	2: "Tracking_number",
	3: "Shipping_address_id",
}

// Decode decodes OrderShipping from json.
func (s *OrderShipping) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderShipping to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Shipping_method_name":
			if err := func() error {
				s.ShippingMethodName.Reset()
				if err := s.ShippingMethodName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Shipping_method_name\"")
			}
		case "Shipping_date":
			if err := func() error {
				s.ShippingDate.Reset()
				if err := s.ShippingDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Shipping_date\"")
			}
		case "Tracking_number":
			if err := func() error {
				s.TrackingNumber.Reset()
				if err := s.TrackingNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tracking_number\"")
			}
		case "Shipping_address_id":
			if err := func() error {
				s.ShippingAddressID.Reset()
				if err := s.ShippingAddressID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Shipping_address_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderShipping")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderShipping) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderShipping) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderTransaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderTransaction) encodeFields(e *jx.Encoder) {
	{
		if s.AvsResponse.Set {
			e.FieldStart("Avs_response")
			s.AvsResponse.Encode(e)
		}
	}
	{
		if s.CvvResponse.Set {
			e.FieldStart("Cvv_response")
			s.CvvResponse.Encode(e)
		}
	}
	{
		if s.ProcessorID.Set {
			e.FieldStart("Processor_id")
			s.ProcessorID.Encode(e)
		}
	}
	{
		if s.GatewayID.Set {
			e.FieldStart("Gateway_id")
			s.GatewayID.Encode(e)
		}
	}
	{
		if s.TransactionID.Set {
			e.FieldStart("Transaction_id")
			s.TransactionID.Encode(e)
		}
	}
	{
		if s.AuthID.Set {
			e.FieldStart("Auth_id")
			s.AuthID.Encode(e)
		}
	}
	{
		if s.PanLocked.Set {
			e.FieldStart("Pan_locked")
			s.PanLocked.Encode(e)
		}
	}
	{
		if s.PreserveGateway.Set {
			e.FieldStart("Preserve_gateway")
			s.PreserveGateway.Encode(e)
		}
	}
	{
		if s.IsRecurring.Set {
			e.FieldStart("Is_recurring")
			s.IsRecurring.Encode(e)
		}
	}
	{
		if s.IsChargeback.Set {
			e.FieldStart("Is_chargeback")
			s.IsChargeback.Encode(e)
		}
	}
	{
		if s.IsFraud.Set {
			e.FieldStart("Is_fraud")
			s.IsFraud.Encode(e)
		}
	}
	{
		if s.IsRma.Set {
			e.FieldStart("Is_rma")
			s.IsRma.Encode(e)
		}
	}
	{
		if s.RmaNumber.Set {
			e.FieldStart("Rma_number")
			s.RmaNumber.Encode(e)
		}
	}
	{
		if s.RmaReason.Set {
			e.FieldStart("Rma_reason")
			s.RmaReason.Encode(e)
		}
	}
	{
		if s.DeclineReason.Set {
			e.FieldStart("Decline_reason")
			s.DeclineReason.Encode(e)
		}
	}
	{
		if s.TransactionDate.Set {
			e.FieldStart("Transaction_date")
			s.TransactionDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PaymentID.Set {
			e.FieldStart("Payment_id")
			s.PaymentID.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrderTransaction = [17]string{
	0:  "Avs_response",
	1:  "Cvv_response",
	2:  "Processor_id",
	3:  "Gateway_id",
	4:  "Transaction_id",
	5:  "Auth_id",
	6:  "Pan_locked",
	7:  "Preserve_gateway",
	8:  "Is_recurring",
	9:  "Is_chargeback",
	10: "Is_fraud",
	11: "Is_rma",
	12: "Rma_number",
	13: "Rma_reason",
	14: "Decline_reason",
	15: "Transaction_date",
	16: "Payment_id",
}

// Decode decodes OrderTransaction from json.
func (s *OrderTransaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderTransaction to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Avs_response":
			if err := func() error {
				s.AvsResponse.Reset()
				if err := s.AvsResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Avs_response\"")
			}
		case "Cvv_response":
			if err := func() error {
				s.CvvResponse.Reset()
				if err := s.CvvResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Cvv_response\"")
			}
		case "Processor_id":
			if err := func() error {
				s.ProcessorID.Reset()
				if err := s.ProcessorID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Processor_id\"")
			}
		case "Gateway_id":
			if err := func() error {
				s.GatewayID.Reset()
				if err := s.GatewayID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Gateway_id\"")
			}
		case "Transaction_id":
			if err := func() error {
				s.TransactionID.Reset()
				if err := s.TransactionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Transaction_id\"")
			}
		case "Auth_id":
			if err := func() error {
				s.AuthID.Reset()
				if err := s.AuthID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Auth_id\"")
			}
		case "Pan_locked":
			if err := func() error {
				s.PanLocked.Reset()
				if err := s.PanLocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Pan_locked\"")
			}
		case "Preserve_gateway":
			if err := func() error {
				s.PreserveGateway.Reset()
				if err := s.PreserveGateway.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Preserve_gateway\"")
			}
		case "Is_recurring":
			if err := func() error {
				s.IsRecurring.Reset()
				if err := s.IsRecurring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Is_recurring\"")
			}
		case "Is_chargeback":
			if err := func() error {
				s.IsChargeback.Reset()
				if err := s.IsChargeback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Is_chargeback\"")
			}
		case "Is_fraud":
			if err := func() error {
				s.IsFraud.Reset()
				if err := s.IsFraud.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Is_fraud\"")
			}
		case "Is_rma":
			if err := func() error {
				s.IsRma.Reset()
				if err := s.IsRma.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Is_rma\"")
			}
		case "Rma_number":
			if err := func() error {
				s.RmaNumber.Reset()
				if err := s.RmaNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Rma_number\"")
			}
		case "Rma_reason":
			if err := func() error {
				s.RmaReason.Reset()
				if err := s.RmaReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Rma_reason\"")
			}
		case "Decline_reason":
			if err := func() error {
				s.DeclineReason.Reset()
				if err := s.DeclineReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Decline_reason\"")
			}
		case "Transaction_date":
			if err := func() error {
				s.TransactionDate.Reset()
				if err := s.TransactionDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Transaction_date\"")
			}
		case "Payment_id":
			if err := func() error {
				s.PaymentID.Reset()
				if err := s.PaymentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Payment_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderTransaction")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderTransaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderTransaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Payment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Payment) encodeFields(e *jx.Encoder) {
	{
		if s.CCType.Set {
			e.FieldStart("CC_type")
			s.CCType.Encode(e)
		}
	}
	{
		if s.CcNumber.Set {
			e.FieldStart("Cc_number")
			s.CcNumber.Encode(e)
		}
	}
	{
		if s.CcExp.Set {
			e.FieldStart("Cc_exp")
			s.CcExp.Encode(e)
		}
	}
	{
		if s.CardSource.Set {
			e.FieldStart("Card_source")
			s.CardSource.Encode(e)
		}
	}
	{
		if s.CheckAccount.Set {
			e.FieldStart("Check_account")
			s.CheckAccount.Encode(e)
		}
	}
	{
		if s.CheckRouting.Set {
			e.FieldStart("Check_routing")
			s.CheckRouting.Encode(e)
		}
	}
	{
		if s.CheckSsn.Set {
			e.FieldStart("Check_ssn")
			s.CheckSsn.Encode(e)
		}
	}
	{
		if s.CardBin.Set {
			e.FieldStart("Card_bin")
			s.CardBin.Encode(e)
		}
	}
	{
		if s.CardBinShort.Set {
			e.FieldStart("Card_bin_short")
			s.CardBinShort.Encode(e)
		}
	}
	{
		if s.PrepaidMatch.Set {
			e.FieldStart("Prepaid_match")
			s.PrepaidMatch.Encode(e)
		}
	}
}

var jsonFieldsNameOfPayment = [10]string{
	0: "CC_type",
	1: "Cc_number",
	2: "Cc_exp",
	3: "Card_source",
	4: "Check_account",
	5: "Check_routing",
	6: "Check_ssn",
	7: "Card_bin",
	8: "Card_bin_short",
	9: "Prepaid_match",
}

// Decode decodes Payment from json.
func (s *Payment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Payment to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "CC_type":
			if err := func() error {
				s.CCType.Reset()
				if err := s.CCType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CC_type\"")
			}
		case "Cc_number":
			if err := func() error {
				s.CcNumber.Reset()
				if err := s.CcNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Cc_number\"")
			}
		case "Cc_exp":
			if err := func() error {
				s.CcExp.Reset()
				if err := s.CcExp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Cc_exp\"")
			}
		case "Card_source":
			if err := func() error {
				s.CardSource.Reset()
				if err := s.CardSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Card_source\"")
			}
		case "Check_account":
			if err := func() error {
				s.CheckAccount.Reset()
				if err := s.CheckAccount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Check_account\"")
			}
		case "Check_routing":
			if err := func() error {
				s.CheckRouting.Reset()
				if err := s.CheckRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Check_routing\"")
			}
		case "Check_ssn":
			if err := func() error {
				s.CheckSsn.Reset()
				if err := s.CheckSsn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Check_ssn\"")
			}
		case "Card_bin":
			if err := func() error {
				s.CardBin.Reset()
				if err := s.CardBin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Card_bin\"")
			}
		case "Card_bin_short":
			if err := func() error {
				s.CardBinShort.Reset()
				if err := s.CardBinShort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Card_bin_short\"")
			}
		case "Prepaid_match":
			if err := func() error {
				s.PrepaidMatch.Reset()
				if err := s.PrepaidMatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Prepaid_match\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Payment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Payment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Payment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PaymentCCType as json.
func (s PaymentCCType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PaymentCCType from json.
func (s *PaymentCCType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaymentCCType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PaymentCCType(v) {
	case PaymentCCTypeMastercard:
		*s = PaymentCCTypeMastercard
	case PaymentCCTypeVisa:
		*s = PaymentCCTypeVisa
	case PaymentCCTypeAmex:
		*s = PaymentCCTypeAmex
	case PaymentCCTypeDiscover:
		*s = PaymentCCTypeDiscover
	default:
		*s = PaymentCCType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PaymentCCType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaymentCCType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
